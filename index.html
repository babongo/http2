<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Http2 by babongo</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Http2</h1>
        <p>HTTP2</p>

        <p class="view"><a href="https://github.com/babongo/http2">View the Project on GitHub <small>babongo/http2</small></a></p>


        <ul>
          <li><a href="https://github.com/babongo/http2/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/babongo/http2/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/babongo/http2">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>
<a name="requirements" class="anchor" href="#requirements"><span class="octicon octicon-link"></span></a>Requirements</h3>

<h4>
<a name="overall" class="anchor" href="#overall"><span class="octicon octicon-link"></span></a>Overall</h4>

<ol>
<li>Be able to run usual HTTP transactions using HTTP/2.0 syntax.</li>
<li>Be able to use HTTP/2.0 specific features (e.g. push, prioritisation, etc.).</li>
<li>Be able to measure software performance/behaviour on well defined workloads.</li>
<li>Be able to test the software base extensively and systematically (unit, regression, integration).</li>
<li>Make it easy for new developers to understand the overall architecture and code structure, and be able to contribute as quickly and as effectively as possible.</li>
<li>Make it easy for users of the software to plug their own implementations for non-core components (e.g. caching and discovery functionality).</li>
</ol><h4>
<a name="client" class="anchor" href="#client"><span class="octicon octicon-link"></span></a>Client</h4>

<ol>
<li>Be able to negotiate a HTTP/2.0 connection with a server for both \ttt{http} and \ttt{https} URIs.</li>
<li>Be able to discover HTTP/2.0 capabilities of a server through DNS or whatever mechanism is going to be defined (on-hold).</li>
<li>Establish and run a successful connection according to spec.</li>
<li>Handle connection errors according to spec.</li>
<li>Be able to re-use previously retrieved resources for new requests (cache).</li>
</ol><h4>
<a name="server" class="anchor" href="#server"><span class="octicon octicon-link"></span></a>Server</h4>

<ol>
<li>Be able to instantiate a server with a set of basic configuration attributes -- at least its transport endpoint, virtual host/origin settings (e.g. TLS configuration), etc.</li>
<li>Be able to register a URI for a configured origin, and associate a static data source.</li>
<li>Be able to register a URI for a configured origin, and associate a dynamic data source.</li>
<li>Be able to associate a set of "related/linked" resources to a registered URI to enable server push towards a willing client.</li>
<li>Be able to unregister a previously registered URI.</li>
<li>URI registration and de-registration can be requested on a running server without stopping it (make it a separate requirement).</li>
</ol><h4>
<a name="proxy" class="anchor" href="#proxy"><span class="octicon octicon-link"></span></a>Proxy</h4>

<p>There is no proxy-specific functionality to be implemented as it is expected that the proxy is put together by the user by composing a Client, a Server, and a Cache.
Anyway, these three components must be designed in a way that makes the proxy use case easy to implement.</p>

<h4>
<a name="profiling" class="anchor" href="#profiling"><span class="octicon octicon-link"></span></a>Profiling</h4>

<ol>
<li>Be able to collect profiling information on well defined work-loads.</li>
<li>Be able to process profiling data and produce visual information out of it (data format must be easy to extract and to feed into common -- \todo{define exactly which} -- visualisation tools).</li>
<li>Be able to enable/disable code instrumentation at run-time or compile-time. </li>
</ol><h4>
<a name="testing" class="anchor" href="#testing"><span class="octicon octicon-link"></span></a>Testing</h4>

<ol>
<li>Be able to test each produced software component in isolation.</li>
<li>Be able to run regression tests easily.</li>
<li>Be able to run performance tests on well defined work loads.</li>
</ol><h4>
<a name="performance" class="anchor" href="#performance"><span class="octicon octicon-link"></span></a>Performance</h4>

<ol>
<li>Client/Server should be able to handle at least X parallel streams on a single connection.</li>
<li>Client/Server should be able to achieve Y Gbps output on a single connection.</li>
<li>Client/Server should be able to handle at least X connections in parallel.</li>
<li>Client/Server should be able to achieve Z Gbps aggregate output.</li>
</ol>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/babongo">babongo</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>