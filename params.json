{"name":"Http2","tagline":"HTTP2","body":"# Requirements\r\n\r\n## Overall\r\n1. Be able to run usual HTTP transactions using HTTP/2.0 syntax.\r\n2. Be able to use HTTP/2.0 specific features (e.g. push, prioritisation, etc.).\r\n3. Be able to measure software performance/behaviour on well defined workloads.\r\n4. Be able to test the software base extensively and systematically (unit, regression, integration).\r\n5. Make it easy for new developers to understand the overall architecture and code structure, and be able to contribute as quickly and as effectively as possible.\r\n6. Make it easy for users of the software to plug their own implementations for non-core components (e.g. caching and discovery functionality).\r\n\r\n## Client\r\n1. Be able to negotiate a HTTP/2.0 connection with a server for both \\ttt{http} and \\ttt{https} URIs.\r\n2. Be able to discover HTTP/2.0 capabilities of a server through DNS or whatever mechanism is going to be defined (on-hold).\r\n3. Establish and run a successful connection according to spec.\r\n4. Handle connection errors according to spec.\r\n5. Be able to re-use previously retrieved resources for new requests (cache).\r\n\r\n## Server\r\n1. Be able to instantiate a server with a set of basic configuration attributes -- at least its transport endpoint, virtual host/origin settings (e.g. TLS configuration), etc.\r\n2. Be able to register a URI for a configured origin, and associate a static data source.\r\n3. Be able to register a URI for a configured origin, and associate a dynamic data source.\r\n4. Be able to associate a set of \"related/linked\" resources to a registered URI to enable server push towards a willing client.\r\n5. Be able to unregister a previously registered URI.\r\n6. URI registration and de-registration can be requested on a running server without stopping it (make it a separate requirement).\r\n\r\n## Proxy\r\nThere is no proxy-specific functionality to be implemented as it is expected that the proxy is put together by the user by composing a Client, a Server, and a Cache.\r\nAnyway, these three components must be designed in a way that makes the proxy use case easy to implement.\r\n\r\n## Profiling\r\n1. Be able to collect profiling information on well defined work-loads.\r\n2. Be able to process profiling data and produce visual information out of it (data format must be easy to extract and to feed into common -- \\todo{define exactly which} -- visualisation tools).\r\n3. Be able to enable/disable code instrumentation at run-time or compile-time. \r\n\r\n## Testing\r\n1. Be able to test each produced software component in isolation.\r\n2. Be able to run regression tests easily.\r\n3. Be able to run performance tests on well defined work loads.\r\n\r\n## Performance\r\n1. Client/Server should be able to handle at least X parallel streams on a single connection.\r\n2. Client/Server should be able to achieve Y Gbps output on a single connection.\r\n3. Client/Server should be able to handle at least X connections in parallel.\r\n4. Client/Server should be able to achieve Z Gbps aggregate output.\r\n\r\n# High Level Design\r\n\r\n## Packages\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}